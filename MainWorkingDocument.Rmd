---
output: html_document
editor_options:
  chunk_output_type: console
---
# Loading Data
```{r}
# install.packages("tidyverse")
# install.packages("fpp3")
# install.packages("imputeTS")
library(tidyverse)
library(fpp3)
library(magrittr)
library(imputeTS)
rm(list = ls())
data <- read_delim("BaselMessungen.csv", delim = ";")
data %<>% select(-c("Wasserstand","Pegel")) %>% as_tsibble()
# working with tibble for EDA (tsibble does not fully support the dplyr package)
# for modelling we will transform the object into a tsibble object
```

# First EDA
```{r}
# setting a nice plotting theme as default
theme_set(
    theme_classic() + 
        theme(
            axis.ticks.length = unit(-0.25, "cm"),
            axis.text.x = element_text(margin = unit(c(0.4,0,0,0), "cm")),
            axis.text.y = element_text(margin = unit(c(0,0.4,0,0), "cm")),
            axis.line = element_blank(),
            panel.grid.major.y = element_line(linetype = 2),
            plot.title = element_text(hjust = 0.5),
            text = element_text(family = "serif"),
            legend.justification = c("right", "top"),
            # legend.position = c(1, 1),
            legend.position = c(.98, .98),
            legend.background = element_rect(fill = NA, color = "black"),
            panel.border = element_rect(fill = NA, size = 1.25),
            strip.text = element_text(size = 12)
            # legend.margin = margin(6, 10, 6, 6)
            # legend.box.background = element_rect(colour = "black")
            )
    
    )

```
## First Inspectional Plot
```{r}
ggplot(data)+
  geom_line(aes(x=Zeitstempel,y=Abflussmenge))
```

## Summary Statistics
```{r}
dim(data)
interval_pull(data$Zeitstempel)
summary(data)
```

## Identifying Missing Values
```{r}
has_gaps(data)
count_gaps(data)
scan_gaps(data)

sum(is.na(data$Abflussmenge))
sum(is.na(data$Abflussmenge))/length(data$Zeitstempel)

# checking time consistency of measurements
check1 <- data %>% as_tibble() %>% drop_na() %>%
  arrange(Zeitstempel) %>%
  mutate(diff = lag(Zeitstempel) - Zeitstempel, diff = as.factor(diff)) %>%
  group_by(diff) %>%
  summarise(counter = n())
check1
```

## Visualising Missing Values
```{r}
# augmenting all time slots with missing data
all_measurements <- tibble(Zeitstempel = seq(as.POSIXct(min(data$Zeitstempel)), as.POSIXct(max(data$Zeitstempel)), by = "5 min"))
data <- data %>% full_join(all_measurements, by = "Zeitstempel")

#old plot (points on time line)
# missing_data_plot <- data %>%
#   filter(is.na(Abflussmenge)) %>%
#   full_join(data[1, ]) %>%
#   mutate(missing_data = ifelse(is.na(Abflussmenge), TRUE, FALSE), missing_data = as.factor(missing_data)) %>%
#   ggplot(aes(Zeitstempel, 0, col = missing_data)) +
#   geom_point(size = 0.5) +
#   scale_x_yearmonth() +
#   theme(axis.text.y = element_blank(), axis.ticks.y = element_blank()) +
#   labs(col = "Missing Value")
# missing_data_plot

missing_datapoints <- data %>%
  filter(is.na(Abflussmenge)) %>% pull(Zeitstempel)

data %>% ggplot(aes(Zeitstempel, Abflussmenge)) + geom_line() + geom_vline(xintercept = missing_datapoints, col = "grey")
```


## Impute Missing Values
```{r}
# data %<>% fill_gaps(.full = TRUE) # somewhat obsolete after augmentation above
ggplot_na_intervals(data)
ggplot_na_gapsize(data)

data <- na_kalman(data)
has_gaps(data)
ggplot_na_imputations(data, data)
```

# Raw AR, MA, ARMA and ARIMA Functions

```{r}
my_MA <- function(ts, q, thetas){
  # verify equal length of q and thetas
  if(q+1!=length(thetas)){errorCondition("Inputs to my_MA are inapproriate.")}
  # thetas need to contain 1 as first value 
  # as the current noise innovation is not scaled => multiplied with 1
  out <- rep(NA, length(ts))
  
  for(i in seq_along(ts)){
    if(i-q<1){
      out[i] <- NA
      
    }else{
      out[i] <- sum(thetas * ts[i:i-q])
  }
  }
  return(out)  
}
my_AR <- function(ts, q, phis){
  # verify equal length of q and thetas
  if(q!=length(thetas)){errorCondition("Inputs to my_AR are inapproriate.")}
  # thetas need to contain 1 as first value 
  # as the current noise innovation is not scaled => multiplied with 1
  out <- rep(NA, length(ts))
  
  for(i in seq_along(ts)){
    if(i-q<1){
      out[i] <- ts[i]
      
    }else{
      out[i] <- sum(phis * out[seq(i-q,i-1,1)]) + ts[i]
    }
    out
  }
  return(out)  
}


# manual testing code
# ts <- c(1:10)
# q <- 3
# thetas <- c(1, 0.8, 0.9, 0.4)
# phis <- c(0.8, 0.9, 0.4)
# usual testing
# my_MA(
#   c(1:10),
#   3,
#   c(1, 0.8, 0.9, 0.4))
set.seed(123)
aux_ts <- rnorm(100)
ar <- my_AR(
  aux_ts,
  1,
  c(0.6))
aux_ts <- tsibble(ts = ts, index = c(1:length(ts)))
aux_ts %>% model(
  AR1 = ARIMA(ts ~ pdq(1, 0, 0), )
)
plot(c(1:length(ar)), ar, type ="l")

```

# Raw Auto-Corr
```{r}
t = 0:300
y_stationary <- rnorm(length(t),mean=1,sd=1) # the stationary time series (ts)
plot(t, y_stationary, "l")

my_autocorr <- function(ts, q){
    aux <- tibble(counter = as.integer(), autocorr = as.double())
    for (i in seq_along(c(1:q))){
    table <-
        tibble(
            ts = ts,
            lagged_ts = lag(ts, i)) %>%
        drop_na() %>%
        summarise(
            autocorr = cov(ts, lagged_ts)/(sd(ts) * sd(lagged_ts))
            )
    out <- table %>% pull(autocorr)
    aux <- aux %>% complete(counter = i, autocorr = out)
    }
    return(aux)
}

test <- acf(y_stationary, 7)
test$acf[-1]
my_autocorr(y_stationary, 7) %>% arrange(counter)  %>% pull(autocorr)
((test$acf[-1] - my_autocorr(y_stationary, 7) %>% arrange(counter)  %>% pull(autocorr))/test$acf[-1]) %>% mean()

```
works fairly accurate â€” relative error 1%



# Decomposition
## Decomposition with STL (LOESS)
```{r}
#aus fpp3
decomposition <- data %>%
  model(stl = STL(Abflussmenge)) %>%
  components()
```

## Visualising the Decomposition
```{r}
decomposition %>%
  as_tsibble() %>%
  autoplot(Abflussmenge, color = "grey") +
  geom_line(mapping= aes(y=trend), colour = "black") +
  labs(
    y = "flow rate",
    x = "time",
    title = "Flow rate of the Rhine in Basel")
```

```{r}
autoplot(decomposition)
```

## Checking Error Term (Heteroscedasticity)
```{r}
#is heteroscedastic
remainder <- decomposition$remainder
acf(remainder)
```
